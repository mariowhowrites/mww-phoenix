["<p>In the spirit of writing more about my development process, I wrote this article alongside building a new feature for my Phoenix-backed blog. I made a deliberate effort to keep the feature small in scope so I could track the various iterations without writing a small novel. Fortunately, since I am building a blog without using any of the dozens of excellent existing CMSs, these kinds of small-but-important tasks abound. </p>","<p>In this case, my task was to add OpenGraph tags to each page to maximize discoverability. For the uninitiated, OpenGraph tags are <code class=\"inline\">meta</pre> tags that you can include in your HTML’s <code class=\"inline\">head</pre> element to share information about the page’s content with popular social media sites. </p>","<p>Because this data is used on most social media platforms to summarize links to your website, this information is oftentimes the first point of contact many people will have with your content. This pushed the feature from a “nice-to-have” priority to “need-it-yesterday”, so let’s get started!</p>","<ol><li>Challenge</li><li>Solution</li><li>Implementation</li></ol>","<p>Edits for clarity aside, I’ve left that structure intact for this article. It may seem self-evident, almost banal, to write outlines in this format, but I feel as if most of the mistakes I’ve made in engineering have come from not fleshing out one of these three concepts in enough detail. You can’t properly think about a solution until you fully understand what you’re trying to solve, and you can’t make a robust implementation until you’ve thought carefully about the right solution. It can be tempting to short-circuit this process by starting to code as soon as you’ve identified a problem, but this adds more development time than it saves in the long run.</p>","<h2>Challenge</h2>","<p>SEO information needs to be set on a per-page basis, but LiveView (to my current knowledge) lacks primitives to set per-page head settings dynamically. There’s a special exception for the <code class=\"inline\">title</pre> tag, which makes sense as the page title is displayed as the tab name in most modern browsers and frequently needs to change. </p>","<p>What we need is a clear means of setting relevant SEO information (OpenGraph and Twitter tags) for each page. This information is primarily used when sharing information on social media, so we need to ensure this information is available as soon as possible, rather than waiting until the page is loaded to fetch this data.</p>","<p>This will likely mean a solution outside of the scope of LiveView, since LiveView communication happens primarily through a web socket, which only initiates a connection after the initial response has already been sent and the webpage has begun loading.</p>","<h2>Solution</h2>","<p>At a most basic level, here’s what needs to be done:</p>","<p>We have access to blog information through a cache, by calling functions like <code class=\"inline\">Cache.get(article_slug)</pre>. These cache functions return Elixir maps, which we need to transform into relevant OpenGraph tags.</p>","<p>When converting data between two mediums that are largely dissimilar, it often helps to create an intermediate representation of data. In this case, our data “pipeline” could look something like:</p>","<hr>","<p>Elixir map → List of HTML tags to render → HTML tags</p>","<hr>","<p>This lets our HTML markup stay fairly logic-free. For each element in our list, render the tag:</p>","<pre><code class=\"hljs language-html\">&lt;%= for {tag, value} &lt;- @meta_tags do %&gt;\n\t&lt;meta property={tag} content={value} /&gt;\n&lt;% end %&gt;</code></pre>","<p>So we know we’ll need to write the logic to convert a blog post into a list with tag information.  We’ll decide exactly what tags we need and in what format during the implementation section. For now, though, a more pressing question: when do we need to set this information?</p>","<p>This information will need to be accessible before the page is rendered. We should parse out headers when we fetch the article and put them into the assigns at that point.</p>","<p>I believe the answer has to do with <code class=\"inline\">live_session</pre>, and creating multiple live sessions to trigger regular page navigation. This should allow us to get some more flexibility around what layout we use and what’s stored in there.</p>","<ul><li>og:title</li><li>og:description</li><li>og:image</li><li>og:url</li><li>twitter:card</li><li>twitter:site</li><li>twitter:creator</li></ul>","<p>Right now, setting meta tags per-route should be easy because we have only two pages. However, the idea of having to carve out separate live_sessions for something that should realistically change from page to page is… strange. I want to think about how this could be improved, but for now let’s focus on getting something working, and refine our solution once we have one.</p>","<h2>Implementation</h2>","<ul><li>og:title - “mariovega.dev”</li><li>og:description - “a website with words on it”</li><li>og:image - latest blog post image?</li><li>og:url - “mariovega.dev”</li><li>twitter:card - “large_summary”</li><li>twitter:creator - “@mariowhowrites”</li></ul>","<ul><li>og:title - article.title</li><li>og:description - article.description</li><li>og:image - Article.desktop_image(article)</li><li>og:url - Article.full_url(article)</li><li>twitter:card -  “large_summary”</li><li>twitter:creator - “@mariowhowrites”</li></ul>","<ul><li>Article.desktop_image(article): string</li><li>Article.full_url(article): string </li></ul>","<p>First implementation:</p>","<pre><code class=\"hljs language-elixir\">defmodule MwwPhoenix.Blog.Article do\n  # ..\n\n  defp site_hostname() do\n    Application.get_env(:mww_phoenix, MwwPhoenixWeb.Endpoint)[:url][:host]\n  end\n\n  def full_image_url(article) do\n    &quot;https://#{site_hostname()}#{article.image}&quot;\n  end\n\n  def build_meta_tags(article) do\n    %{\n      &quot;og:title&quot; =&gt; article.title,\n      &quot;og:description&quot; =&gt; article.description,\n      &quot;og:image&quot; =&gt; desktop_image_url(article),\n      &quot;og:url&quot; =&gt; full_url(article),\n      &quot;twitter:card&quot; =&gt; &quot;summary_large_image&quot;,\n      &quot;twitter:creator&quot; =&gt; &quot;@mariowhowrites&quot;\n    }\n  end\n\n  def desktop_image_url(article) do\n    &quot;https://#{site_hostname()}/images/responsive/desktop/#{Path.basename(article.image)}&quot;\n  end\n\n  def mobile_image_url(article) do\n    &quot;https://#{site_hostname()}/images/responsive/mobile/#{Path.basename(article.image)}&quot;\n  end\n\n  def full_url(article) do\n    &quot;https://#{site_hostname()}/articles/#{article.slug}&quot;\n  end\nend</code></pre>","<p>This makes meta tags based on article data. Next step is to push this data as far up the response chain as possible, as this data needs to exist when the page is first rendered to be useful at all from an SEO perspective. Let’s create a <code class=\"inline\">show_root</pre> layout file that will handle our SEO tags for a given article, and use that here:</p>","<pre><code class=\"hljs language-elixir\">defmodule MwwPhoenixWeb.Router do\n\t# ...\n\n\tscope &quot;/&quot;, MwwPhoenixWeb do\n    pipe_through :browser\n\n    live &quot;/&quot;, ArticleLive.Index, :index\n\n    get &quot;/feed&quot;, RssController, :all\n\n    live_session :show, root_layout: {MwwPhoenixWeb.Layouts, :show_root} do\n      pipe_through [:assign_meta_tags]\n      live &quot;/articles/:slug&quot;, ArticleLive.Show, :show\n    end\n  end\n\n  def assign_meta_tags(conn, _opts) do\n    article = Cache.get(conn.params[&quot;slug&quot;])\n\n    assign(conn, :meta_tags, Article.build_meta_tags(article))\n  end\nend</code></pre>","<p>Next, let’s actually make a <code class=\"inline\">show_root</pre> layout, and make sure to use our new <code class=\"inline\">meta_tags</pre> assign in it:</p>","<pre><code class=\"hljs language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; style=&quot;scrollbar-gutter: stable;&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;\n    &lt;meta name=&quot;csrf-token&quot; content={get_csrf_token()} /&gt;\n    &lt;.live_title suffix=&quot; · mariovega.dev&quot;&gt;\n      &lt;%= assigns[:page_title] || &quot;MwwPhoenix&quot; %&gt;\n    &lt;/.live_title&gt;\n\t\t&lt;%!-- add meta tags for SEO accessibility --%&gt;\n    &lt;%= for {tag, value} &lt;- @conn.assigns[:meta_tags] do %&gt;\n      &lt;%= if String.contains?(tag, &quot;twitter&quot;) do %&gt;\n          &lt;meta name={tag} content={value} /&gt;\n      &lt;% else %&gt;\n          &lt;meta property={tag} content={value} /&gt;\n      &lt;% end %&gt;\n    &lt;% end %&gt;\n    &lt;link phx-track-static rel=&quot;stylesheet&quot; href={~p&quot;/assets/app.css&quot;}&gt;\n    &lt;link media=&quot;print&quot; onload=&quot;this.media = &#39;all&#39;&quot; rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/an-old-hope.min.css&quot;&gt;\n    &lt;script async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script defer phx-track-static type=&quot;text/javascript&quot; src={~p&quot;/assets/app.js&quot;}&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body class=&quot;bg-white antialiased&quot;&gt;\n    &lt;%= @inner_content %&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>","<p>Having created a <code class=\"inline\">live_session</pre>, I now believe that there’s no need for a <code class=\"inline\">live_session</pre>. Instead, I think we can use one root layout, and write one <code class=\"inline\">add_meta_tags</pre> plug that’ll determine what SEO tags to use and apply them accordingly.</p>","<p>As far as I can think at the moment, the risk of this is that we end up with a “shadow router”, where for each route we also need a corresponding method in the plug. </p>","<p>I think this is a fine tradeoff, since there’s no way we’ll ever be able to automatically derive this information anyways.</p>","<p>I made a new module under the namespace <code class=\"inline\">Plugs.AssignMetaTags</pre>:</p>","<pre><code class=\"hljs language-elixir\">defmodule MwwPhoenixWeb.Plugs.AssignMetaTags do\n  import Plug.Conn\n  alias MwwPhoenix.Blog.{Cache, Article}\n\n  def assign_meta_tags(conn, _opts) do\n    {route, _list, _opts} = conn.private.phoenix_live_view\n\n    assign_tags(conn, route)\n  end\n\n  defp assign_tags(conn, route) when route == MwwPhoenixWeb.ArticleLive.Show do\n    article = Cache.get(conn.params[&quot;slug&quot;])\n\n    assign(conn, :meta_tags, Article.build_meta_tags(article))\n  end\n\n  defp assign_tags(conn, route) when route == MwwPhoenixWeb.ArticleLive.Index do\n    assign(conn, :meta_tags, %{\n      &quot;og:title&quot; =&gt; &quot;mariovega.dev&quot;,\n      &quot;og:description&quot; =&gt; &quot;A website with words about various subjects&quot;,\n      &quot;og:url&quot; =&gt; &quot;https://mariovega.dev&quot;,\n      &quot;twitter:card&quot; =&gt; &quot;summary&quot;,\n      &quot;twitter:creator&quot; =&gt; &quot;@mariowhowrites&quot;\n    })\n  end\n\n  # default case, return nothing\n  defp assign_tags(conn, _route) do\n    assign(conn, :meta_tags, [])\n  end\nend</code></pre>","<p>We get the route name from the connection’s <code class=\"inline\">private</pre> key, then match that in the guard for each iteration of <code class=\"inline\">assign_tags</pre>. This method does feel a tad brittle, as it depends on the structure of the conn’s <code class=\"inline\">private</pre> key staying the same across new versions of LiveView, but it works for the time being and provides a fairly readable structure to the code.</p>","<p>Testing this runs into an issue: because we are no longer partitioning out each route into its own <code class=\"inline\">live_session</pre>, head values do not change as we navigate from page to page since Phoenix no longer knows this is something we need to do.</p>","<p>For example, say we’re reading Article A. If we move to Article B, then look at our page’s HTML, we’ll still see the meta tags for Article A.</p>","<ol><li>The primary reason to include these meta tags is for better sharing and discovery on social media. Since the crawlers for social media websites only need information from the first page visited (the page being linked to), we should be able to satisfy those requirements if the initial request always produces correct meta tags.</li><li>Separating each page into new <code class=\"inline\">live_session</pre> instances won’t actually fix any case in which one article links to another. Since we wouldn’t be changing base routes, Phoenix wouldn’t know to rebuild the meta tags and we’d run into the same issue.</li></ol>","<p>The solution as implemented will solve the immediate issue at hand, and I cannot think of an instance in which the way it isn’t optimal will make a difference.</p>","<p>I’m wondering what a better solution might look like. I’m not sure that there is a means of updating meta tags that doesn’t involve a PR into LiveView itself. </p>","<p>We know that LiveView already contains one example of updating the root template in real time with the <code class=\"inline\">page_title</pre> assign. The question then becomes whether such an exemption should be expanded from a one-variable exemption to an arbitrary exemption allowing developers to register key-value pairs into LiveView. </p>","<p>Ultimately, I don’t think updating OpenGraph tags in realtime is important enough to warrant such an expansion.</p>"]